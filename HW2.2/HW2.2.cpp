/* Тема: Алгоритмы и структуры данных. Динамическое программирование и “жадность”
Задача 2. Ускоряем Фибоначчи
Наивное решение задачи по вычислению чисел Фибоначчи является довольно дорогим по времени,
при этом совсем не использует дополнительную память. Давайте исправим это с помощью применения
динамического программирования к рекурсии.

Ваша задача — изменить алгоритм вычисления n-го числа Фибоначчи так,
чтобы сложность алгоритма по скорости составляла O(n) и по памяти тоже была порядка O(n) */

#include <iostream>

int fib(int N)
{
    if (N == 1 or N == 2)
    {
        return 1;
    }
    else
    {
        return (fib(N - 1) + fib(N - 2));
    }
}

int main()
{
    setlocale(LC_ALL, "Russian");
    int N, stop = 1, arr_memory[101] = { 0, 1, 1 };
    std::cout << "Для завершения работы программы введите 0" << std::endl;

    while (stop == 1)
    {
        std::cout << "Введите порядковый номер (до 100 вкл.) для расчета числа последовательности Фибоначчи или 0 для выхода: ";
        std::cin >> N;
        if (N == 0)
        {
            stop = 0;
        }
        else
        {
            if (arr_memory[N] == 0)
            {
                arr_memory[N] = fib(N);
            }
            std::cout << "Элемент " << N << ": " << arr_memory[N] << std::endl;
        }
    }

    return 0;
}